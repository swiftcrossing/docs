function parse_git_branch () {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

RED="\[\033[0;31m\]"
YELLOW="\[\033[0;33m\]"
GREEN="\[\033[0;32m\]"
BLUE="\[\033[0;34m\]"
NO_COLOR="\[\033[0m\]"

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

export PROMPT_COMMAND='PS1X=$(p="${PWD#${HOME}}"; [ "${PWD}" != "${p}" ] && printf "~"; IFS=/; for q in ${p:1}; do printf /${q:0:2}; done; printf "${q:2}")'
export PS1="$NO_COLOR\${PS1X}$YELLOW\$(parse_git_branch)$NO_COLOR\$ "
export SVN_EDITOR=vim
export EDITOR=vim
export PATH=$PATH:/Users/renrawnalon/android-sdk-macosx/platform-tools/
export PATH=$PATH:/Users/renrawnalon/android-sdk-macosx/platforms/:/usr/bin/
export PATH=$PATH:$HOME/infer-osx/infer/bin
export PATH=$PATH:/opt/local/bin:/opt/local/sbin
export PATH=$PATH:$HOME/.local/bin
export PATH="$HOME/.fastlane/bin:$PATH"
export CPATH="$(xcrun --show-sdk-path)/usr/include"

# Set `python` and `pip` to use version installed via `pyenv`
if command -v pyenv 1>/dev/null 2>&1; then
    eval "$(pyenv init -)"
fi

# Setup Ruby environment to use version installe via `rbenv`
if which rbenv > /dev/null; then
    eval "$(rbenv init -)";
fi

# Setup nmv node management path
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm

# Source local aliases managed outside of source control
if [ -f ~/.bash_aliases ];
then
	echo 'Sourced .bash_aliases'
	source ~/.bash_aliases
fi

# cd ../.. = cd ...
# Source: http://www.commandlinefu.com/commands/view/3936
cd() { if [[ "$1" =~ ^\.\.+$ ]];then local a dir;a=${#1};while [ $a -ne 1 ];do dir=${dir}"../";((a--));done;builtin cd $dir;else builtin cd "$@";fi ;}

# git autocomplete
source ~/.git-completion.bash

# bash Aliases
alias ll='ls -la'
alias mkdir="mkdir -p"
# less interprets color escape sequences instead of
# just printing them to the screen
alias less="less -R"

alias tree="tree -NC -l"

# ifconfig
#alias ip=‘echo local; ifconfig en0 | grep inet| grep -v inet6| sed -e ’\’‘s/netmask.*[0-9]$//g’\‘’| sed -e ’\’‘s/[^0-9.]//g’\‘’; echo global;curl ifconfig.co’

# Xcode Aliases
alias openproj='open *.xcodeproj'
alias deletederiveddata='rm -rf ~/Library/Developer/Xcode/DerivedData/*'
alias ddd='deletederiveddata'
alias lldd='ll ~/Library/Developer/Xcode/DerivedData/'
alias cddd='cd ~/Library/Developer/Xcode/DerivedData/'
alias cleanupxcode="\
  du -h -d 1 ~/Library/Developer/Xcode | sort -h;\
  cd ~/Library/Developer/Xcode/iOS\ DeviceSupport && pwd && du -h -d 1 . | sort -h;\
  cd ~/Library/Developer/Xcode/watchOS\ DeviceSupport && pwd && du -h -d 1 . | sort -h;\
  cd ~/Library/Developer/Xcode/Archives && pwd && du -h -d 1 . | sort -h;\
  cd ~/Library/Developer/CoreSimulator && pwd && du -h -d 1 . | sort -h;\
  cd ~/Library/Developer/CoreSimulator/Devices && pwd && du -h -d 1 . | sort -h;\
  cd ~/Library/Developer/CoreSimulator/Caches && pwd && du -h -d 1 . | sort -h;\
  cd ~/Library/Caches && pwd && du -sh com.apple.dt.Xcode && du -sh org.carthage.CarthageKit;\
  echo 'run: \`xcrun simctl delete unavailable\` to remove unused simulators from ~/Library/Developer/CoreSimulator';\
  echo 'run: \`(cd ~/Library/Developer/CoreSimulator && grep -irn SimRuntime.iOS- .)\` to find other old Simulators to delete.';\
  echo 'check \`echo https://ajith.blog/xcode-users-can-free-up-space-on-your-mac | pbcopy\` for more details and tips.';\
  "

# vim Aliases
alias bashrc="vim $HOME/.bashrc; if [ -f $HOME/.bash_profile ] ; then . $HOME/.bash_profile ; echo 'Sourced .bash_profile' ; else . $HOME/.bashrc ; echo 'Sourced .bashrc' ; fi"
alias bashaliases="vim $HOME/.bash_aliases; . $HOME/.bash_aliases ; echo 'Sourced .bash_aliases' ;"
alias vimrc="vim $HOME/.vimrc"
alias vimrclocal="vim $HOME/.vimrc_local"
alias gitconfig="vim $HOME/.gitconfig"
alias vimproj="echo $(git rev-parse --show-toplevel); vim $(git rev-parse --show-toplevel)/*.xcodeproj/project.pbxproj"
alias vim='vim -p ' # make sure vim opens up tabs for multiple files

# ctags Aliases
alias ctags="`brew --prefix`/bin/ctags"
alias ctagsgen='ctags -R -f ./.git/tags .'

#npm Aliases
alias npm-local='PATH=$(npm bin):$PATH'

# git Aliases
alias ga='git add'
alias gaA='git add -A'
alias gap='git add -p'
alias gaproj='git aproj'
alias gb='git branch'
alias gc='git commit'
alias gca='git commit --amend'
alias gco='git checkout'
alias gcp='git cherry-pick'
alias gd='git diff'
alias gdt='git difftool'
alias gdc='git diff --cached'
alias gf='git fetch'
alias gfa='git fetch --all'
alias gfp='git fetch -p'
alias gl='git log'
alias gmnf='git merge --no-ff'
alias grb='git rebase'
alias grba='git rebase --abort'
alias grbs='git rebase --skip'
alias grbc='git rebase --continue'
alias grbi='git rebase -i'
alias grbo='git rebase --onto'
alias grhe='git reset HEAD'
alias grha='git reset --hard'
alias gst='git stash'
alias grbdev='git fetch -p; git rb origin/develop'
alias grbmas='git fetch -p; git rb origin/master'
alias grbidev='git fetch -p; git rbi origin/develop'
alias grbimas='git fetch -p; git rbi origin/master'

# gitk Aliases
alias gitk='gitk 2>/dev/null &'

# Bundle Aliases
alias bepi='bundle exec pod install'
alias bepru='bundle exec pod repo update'
alias be='bundle exec'
alias bef='bundle exec fastlane'
alias bep='bundle exec pod'

# screen Aliases
alias screen='screen -R'

# iOS Simulator Screenshots
alias simvideo='xcrun simctl io booted recordVideo appvideo.mov'
alias simscreenshot='xcrun simctl io booted screenshot'

# tmux Startup function
function tmx()
{
    if tmux attach ;
    then
        return
    fi

    if tmux has-session -t 'sess' ;
    then
        return
    fi

    tmux new-session -n 'man' -s 'sess' -d
    tmux new-window -n 'manserve'
    tmux new-window -n 'mandev'
    tmux new-window -n 'lab'
    tmux new-window -n 'labserve'
    tmux new-window -n 'labdev'
    tmux new-window -n 'vpn'
    tmux select-window -t 'man'
    tmux attach-session -d
}


# git helper functions

function glga ()
{
	ssh-gas -q ; git log --show-signature --graph --decorate --color --all "$@" | less -R
}

function glg ()
{
	ssh-gas -q ; git log --show-signature --graph --branches --tags --remotes --decorate --color "$@" --date-order | less -R
}

function garbc ()
{
	ssh-gas -q ; git add -A ; git rebase --continue
}

function gaca ()
{
	ssh-gas -q ; git add -A ; git commit --amend
}

function gcm ()
{
	ssh-gas -q ; git commit -m "$*"
}

function gcam ()
{
	ssh-gas -q ; git commit -a -m "$*"
}

function gcAm ()
{
	ssh-gas -q ; git add -A ; git commit -m "$*"
}

function gcmp ()
{
	ssh-gas -q ; git commit -m "$*" ; git push
}

function gcamp ()
{
	ssh-gas -q ; git commit -a -m "$*" ; git push
}

function gcAmp ()
{
	ssh-gas -q ; git add -A ; git commit -m "$*" ; git push
}

function gs ()
{
    ssh-gas -q

    # run git status
    git status

    # See if there are any uninitialized submodules.
    git submodule status | cut -c1 | grep -- '-' &> /dev/null
    local ret="$?"

    if [ "$ret" = 0 ] ; then
        echo
        echo "Uninitialized submodules.  Run \`git submodule update --init\`"
    fi
}

# SSH Get Auth Sock.
# This is a command to automatically update the SSH_AUTH_SOCK env var.
# If "-q" is passed, then nothing will be output on error.
# If "-v" is passed, then the auth sock that is currently being used
# will be output.
# (This is needed when connecting to a previously running
# screen session, since the SSH_AUTH_SOCK variable will be the
# previous one we were using.  We need a new updated one
# for this new connection.)
function ssh-gas ()
{
	local QUIET=""
	local VERBOSE=""

	for arg in "$@" ; do
		if [[ "$arg" == '-h' || "$arg" == "--help" ]] ; then
			echo "Usage: ${FUNCNAME[0]} [-h] [-v]"
			echo "Set SSH_AUTH_SOCK environment variable."
			return
		elif [[ "$arg" == '-v' || "$arg" == "--verbose" ]] ; then
			VERBOSE=1
		elif [[ "$arg" == '-q' || "$arg" == "--quiet" ]] ; then
			QUIET=1
		else
			die "Unknown argument \"${arg}\""
		fi
	done

	# get all the existing agent files
	shopt -q extglob
	local SHOPT_PREV_VAL="$?"
	shopt -s extglob
	local agent_files="$(ls -rt /tmp/ssh-+([A-Za-z0-9 ])/agent.+([0-9]) 2>/dev/null)"
	if  [ "$SHOPT_PREV_VAL" -eq "1" ] ; then
		shopt -u extglob
	fi

	# make sure there actually are auth socks to get
	if [ -z "$agent_files" ] ; then
		[ ! "$QUIET" ] && echo "ERROR: no auth sock available"
		return
	fi

	# get the most recently added ssh auth sock
	local auth_sock="$(echo "$agent_files" | tail -1)"
	[ "$VERBOSE" ] && echo "using auth sock: $auth_sock"
	export SSH_AUTH_SOCK="$auth_sock"
}

function rename ()
{
    for f in $1*; do mv "$f" $(echo "$f" | sed "s/^$1/$2/g"); done
}

function removeSpaces ()
{
    for f in $1*; do mv "$f" $(echo "$f" | sed "s/ //g"); done
}
